{
  "input": "Đầu Vào",
  "output": "Kết Quả",
  "input_number": "Số Đầu Vào",
  "output_number": "Kết Quả",
  "encode": "Mã hóa",
  "decode": "Giải mã",
  "decoded": "Đã giải mã {{length}} kí tự",
  "case": "CHIẾN LƯỢC",
  "foreign": "KHOẢNG TRẮNG",
  "case_1": "Giữ Nguyên",
  "case_2": "Chữ In Hoa",
  "case_3": "Chữ Thường",
  "include": "Bao gồm",
  "ignore": "Loại bỏ",
  "alphabet": "BẢN CHỮ CÁI",
  "to_integer": "của hai số nguyên",
  "to_text": "sang văn bản",
  "key": "khóa",
  "utils_word": "Mã hóa và giải mã",
  "ceasar": "mật mã Ceasar",
  "ceasar_desc": " là một trong những kỹ thuật mã hóa đơn giản nhất và được biết đến rộng rãi nhất. Nó là một loại mật mã thay thế, trong đó mỗi chữ cái trong bản rõ được thay thế bằng một chữ cái với một số vị trí cố định trong bảng chữ cái.",
  "affine": "mật mã Affine",
  "affine_desc": "  là một loại mật mã thay thế đơn pha , trong đó mỗi chữ cái trong bảng chữ cái được ánh xạ tới tương đương số của nó, được mã hóa bằng một hàm toán học đơn giản và được chuyển đổi trở lại thành một chữ cái. Công thức được sử dụng có nghĩa là mỗi chữ cái mã hóa thành một chữ cái khác, và ngược lại, có nghĩa là mật mã về cơ bản là một mật mã thay thế tiêu chuẩn với quy tắc điều chỉnh chữ cái nào đi tới chữ cái nào. Do đó, nó có những điểm yếu của tất cả các mật mã thay thế. Mỗi chữ cái được kết hợp với hàm ( ax + b ) mod 26 , trong đó b là độ lớn của dịch chuyển.",
  "reverse": "mật mã đảo ngược",
  "reverse_desc": " sử dụng một mẫu đảo ngược chuỗi văn bản thuần túy để chuyển đổi thành văn bản mật mã. Quá trình mã hóa và giải mã giống nhau. Để giải mã văn bản mật mã, người dùng chỉ cần đảo ngược văn bản mật mã để có được văn bản thuần túy.",
  "transposition": "mật mã đổi chỗ",
  "transposition_desc": " là một phương pháp mã hóa trong đó các vị trí được giữ bởi các đơn vị của bản rõ (thường là các ký tự hoặc nhóm ký tự) được dịch chuyển theo một hệ thống thông thường, do đó bản mã tạo thành một hoán vị của bản rõ.",
  "cal_modulo": "tính Modulo",
  "oper_modulo": "toán tử Modulo",
  "cal": "tính",
  "type_input": "KIỂU ĐẦU VÀO",
  "type_1": "số",
  "type_2": "lũy thừa",
  "type_3": "cơ số",
  "type_4": "số mũ",
  "modulo_desc": " trả về phần còn lại hoặc phần còn lại có dấu của một phép chia, sau khi một số này bị chia cho một số khác (được gọi là mô đun của phép toán). Cho hai số dương a và n, modulo n (viết tắt là mod n) là phần dư của phép chia Euclide của a cho n, trong đó a là số bị chia và n là số bị chia. Phép toán modulo được phân biệt với mod biểu tượng, dùng để chỉ modulus (hoặc số chia) mà nó đang tính toán.",
  "simple_substitution": "mật mã thay thế đơn",
  "simple_substitution_desc": " có thể được chứng minh bằng cách viết ra bảng chữ cái theo một số thứ tự để thể hiện sự thay thế. Đây được gọi là bảng chữ cái thay thế. Bảng chữ cái mật mã có thể bị dịch chuyển hoặc đảo ngược (tạo ra mật mã Caesar và Atbash, tương ứng) hoặc xáo trộn theo một kiểu phức tạp hơn, trong trường hợp đó nó được gọi là bảng chữ cái hỗn hợp hoặc bảng chữ cái loạn trí.",
  "mod_inverse": "nghịch đảo Modulo",
  "mod_inverse_desc": " của số nguyên a là số nguyên x sao cho tích ax đồng dư bằng 1 theo môđun m. Trong ký hiệu tiêu chuẩn của số học mô-đun, sự đồng dư này được viết là ax ≡ 1 (mod m), là cách viết tắt của câu lệnh mà m chia (đều) cho đại lượng ax - 1, hoặc nói một cách khác, phần dư sau chia ax cho số nguyên m được 1.",
  "oper_mod_inverse": "tính toán Modulo nghịch đảo",
  "not_found": "Không tìm thấy. Vui lòng kiểm tra đầu vào của bạn!",
  "footer": " là một ứng dụng web cung cấp các mô-đun để mã hóa và giải mã các mật mã phổ biến. Ngoài ra, CipherVip còn có các tiện ích như tính modulo và tìm mô-đun nghịch đảo."
}
